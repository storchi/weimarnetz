# iw phy phy0 interface add moni0 type monitor
# cat /sys/kernel/debug/ieee80211/phy0/ath9k/wiphy

# Idee, wie man mit mehreren wlan-karten klarkommt: 
#    Erstes WIFI_DEV steht sowohl in normaler Variablenliste,
#    als auch in /tmp/wifi_$DEV zum includen. So werden Operationen
#    auf alle Elemente in der Liste gemacht:
#    (es muss also nur was included werden, wenn es mehrere wireless-karten gibt)
#    (bei einer wlan-karte gibt es kein $WIFI_DEV_NEXT)
#
# for WIFI_DEV in $WIFI_DEVS; do {
#	do_some_stuff_with_normal_vars
#	[ -n "$WIFI_DEV_NEXT" ] && . $WIFI_DEV_NEXT	# inluding VAR-set for next WIFI_DEV
# } done						# (last entry must point to first-device)

_wl ()		# ARG1: must be WIFI_DEV
{
	/usr/sbin/wl -i "$@" 2>/dev/null
}

_wifi_driver_is_old_broadcom()
{
	test -e /usr/sbin/wl
}

_wifi_minstrel()
{
	local mac="$1"
	local option="$2"
	local wifi_dev="$3"

	_wifi minstrel_extract_raw_and_real_txrate_from_neigh_with_highest_success_rate "$mac" "$option" "$wifi_dev"
}

_wifi_minstrel_extract_raw_and_real_txrate_from_neigh_with_highest_success_rate()	# fixme! rename and rework for: _wifi_minstrel_effective_throughput_rate_tupel_max
{
	local mac="$1"		# or IP
	local option="$2"	# debug
	local wifi_dev="${3:-$WIFIDEV}"

	case "$mac" in
		*:*)
			:
		;;
		*)
			_sanitizer do "$mac" ip4 check && {
				mac="$( _net ip2mac $mac )"
			}
		;;
	esac

	local file="/sys/kernel/debug/ieee80211/phy0/netdev:${wifi_dev}/stations/$mac/rc_stats"
	local line result targetline rate throughput efficiency system
	local max=0

	[ -e "$file" ] || return

	[ "$option" = "debug" ] && {
		_log do minstrel_out daemon debug "output of $file"
		cat "$file"
		echo
	}

	percent()
	{
		if   [ "$1" -lt 100 ]; then
			echo "0"
		elif [ "$2" = "0" ]; then
			echo "0"
		else
			echo "$(( ( $1 * 100 ) / $2 ))"
		fi
	}

	while read line; do {

		case "$line" in
			Type*|type*)
				continue
			;;
			T*|t*)			# only use lines with highest/2nd-highest rate
				set $line
			;;
			"HT20/LGI T"*|"HT20/SGI T"*|"HT40/LGI T"*|"HT40/SGI T"*)
				set $line
				shift
			;;
			"HT20/LGI  t"*|"HT20/SGI  t"*|"HT40/LGI  t"*|"HT40/SGI  t"*)
				set $line
				shift
			;;
			*)
				continue
			;;
		esac

# 		logger -s "interesting line: 1: $1 2: $2 3: $3 4:$3 5: $5 6: $6 7: $7 8: $8 9: $9 10: ${10}"

		case "$2" in
			1|2|5.5|11|6|9|12|18|24|36|48|54|*MCS*)

				if [ -n "$9" ]; then
					result="$( percent "$8" "$9" )"
				else
					result="$( percent "$7" "$8" )"
				fi

				[ $result -gt $max ] && {
					max=$result
					targetline="$line"
				}
			;;
			*)
				case "$3" in
					ewma|count*)
						:
					;;
					*)
						if [ -n "${10}" ]; then
							result="$( percent "$9" "${10}" )"
						else
							result="$( percent "$7" "$8" )"
							
						fi
						
						[ $result -gt $max ] && {
							max=$result
							targetline="$line"
						}
					;;
				esac
			;;
		esac

	} done <$file

	[ -n "$targetline" ] && {

		set $targetline
# 		logger -s "TL 1: $1 2: $2 3: $3 4:$3 5: $5 6: $6 7: $7 8: $8 9: $9"

		case "$2" in
			*MCS*)
				system="n"
				rate="$2"
				throughput="$3"
			;;
			1|2|5.5|11|6|9|12|18|24|36|48|54)
				system="g"
				rate="$2"
				throughput="$3"
			;;
			*)
				rate="$3"
				throughput="$4"
			;;
		esac

		[ "$rate" = "0" ] || {

#			logger -s "rate: $rate"

			case "$rate" in
				*MCS*)
					system="n"
					rate="$( _wifi math_mcs2rate "$1" "$1" "$rate" "$option" )"
#					logger -s "rate: $rate"
				;;
				*)
					system="g"
				;;
			esac

			if [ "${throughput%.*}" = "0" ]; then
				efficiency="${throughput#*.}"				# 0.9 -> 9
			else
				efficiency="${throughput%.*}${throughput#*.}"		# 42.6 -> 426
			fi

			case "$rate" in
				"5.5")
					efficiency="$(( ( $efficiency * 100 ) / 55 ))"		# [percent]
				;;
				*)
					efficiency="$(( ( $efficiency * 10 ) / $rate ))"	# [percent]
				;;
			esac
		}
	}

	echo "txrate=${rate:-0};txthroughput=${throughput:-0};efficiency=${efficiency:-0};system=${system};"
}

_wifi_math_mcs2rate()			# fixme! output spatial streams, coding rate, modulation type?
{
	local funcname="wifi_math_mcs2rate"
	local channel_width="$1"		# e.g. HT20/HT40
	local guard_interval_type="$2"		# e.g. LGI/SGI = 400/800ns
	local mcs_index="$3"			# e.g. 0...15		# fixme! should work for 0...31
	local debug="$4"
	local rate
	local spatial_streams coding_rate modulation_type avg_ampdu_length	# fixme!

	case "$channel_width" in
		*20*) channel_width="20" ;;
		*40*) channel_width="40" ;;
	esac

	case "$guard_interval_type" in
		*SGI*) guard_interval_type="short" ;;
		*LGI*) guard_interval_type="long" ;;
	esac

	case "$mcs_index" in
		*[0-9]) mcs_index="${mcs_index#*MCS}" ;;	# MCS12 -> 12
	esac

	[ -n "$debug" ] && {
		case "$mcs_index" in
				0|1|2|3|4|5|6|7) spatial_streams="1" ;;
			  8|9|10|11|12|13|14|15) spatial_streams="2" ;;
			16|17|18|19|20|21|22|23) spatial_streams="3" ;;
			24|25|26|27|28|29|30|31) spatial_streams="4" ;;
		esac

		case "$mcs_index" in
			  0|1|3|8|9|11|16|17|19|24|25|27) coding_rate="1/2" ;;
					      5|13|21|29) coding_rate="2/3" ;;
			2|4|6|10|12|14|18|20|22|26|28|30) coding_rate="3/4" ;;
					      7|15|23|31) coding_rate="5/6" ;;
		esac

		case "$mcs_index" in
						  0|8|16) modulation_type="BPSK" ;;
				    1|2|9|10|17|18|24|25) modulation_type="QPSK" ;;
				   3|4|11|12|19|20|27|28) modulation_type="16QAM" ;;
			5|6|7|13|14|15|21|22|23|29|30|31) modulation_type="64QAM" ;;
		esac

		_log do $funcname daemon debug "channel_width: $channel_width guard_interval_type: $guard_interval_type mcs_index: $mcs_index spatial_streams: $spatial_streams coding_rate: $coding_rate modulation_type: $modulation_type"
	}

	case "$channel_width" in
		20)
			case "$guard_interval_type" in
				long)
					case "$mcs_index" in
						0) rate="6.5" ;;
						1) rate="13" ;;
						2) rate="9.5" ;;
						3) rate="26" ;;
						4) rate="39" ;;
						5) rate="52" ;;
						6) rate="58.5" ;;
						7) rate="65" ;;
						8) rate="13" ;;
						9) rate="26" ;;
						10) rate="39" ;;
						11) rate="52" ;;
						12) rate="78" ;;
						13) rate="104" ;;
						14) rate="117" ;;
						15) rate="130" ;;
					esac
				;;
				short)
					case "$mcs_index" in
						0) rate="7.2" ;;
						1) rate="14.4" ;;
						2) rate="21.7" ;;
						3) rate="28.9" ;;
						4) rate="43.3" ;;
						5) rate="57.8" ;;
						6) rate="65" ;;
						7) rate="72.2" ;;
						8) rate="14.4" ;;
						9) rate="28.9" ;;
						10) rate="43.3" ;;
						11) rate="57.8" ;;
						12) rate="86.7" ;;
						13) rate="115.6" ;;
						14) rate="130" ;;
						15) rate="144.4" ;;
					esac
				;;
			esac
		;;
		40)
			case "$guard_interval_type" in
				long)
					case "$mcs_index" in
						0) rate="13.5" ;;
						1) rate="27" ;;
						2) rate="40.5" ;;
						3) rate="54" ;;
						4) rate="81" ;;
						5) rate="108" ;;
						6) rate="121.5" ;;
						7) rate="135" ;;
						8) rate="27" ;;
						9) rate="54" ;;
						10) rate="81" ;;
						11) rate="108" ;;
						12) rate="162" ;;
						13) rate="216" ;;
						14) rate="243" ;;
						15) rate="270" ;;
					esac
				;;
				short)
					case "$mcs_index" in
						0) rate="15" ;;
						1) rate="30" ;;
						2) rate="45" ;;
						3) rate="60" ;;
						4) rate="90" ;;
						5) rate="120" ;;
						6) rate="135" ;;
						7) rate="150" ;;
						8) rate="30" ;;
						9) rate="60" ;;
						10) rate="90" ;;
						11) rate="120" ;;
						12) rate="180" ;;
						13) rate="240" ;;
						14) rate="270" ;;
						15) rate="300" ;;
					esac
				;;
			esac
		;;
	esac

	echo "$rate"
}

_wifi_params ()
{
	local VAR
	local WIFI_DEVS="$( _wifi devs_list )"
	local THIS_WIFI_DEV

	echo "WIFI_DEVS='$WIFI_DEVS'"	
	
	for THIS_WIFI_DEV in $WIFI_DEVS; do {

		_wifi vendor_and_model  >/tmp/wifi_hardware
		. /tmp/wifi_hardware

		if [ "$WIFI_VENDOR" = "broadcom" ]; then
			_wifi params_broadcom_wlstatus $THIS_WIFI_DEV
		else
			_wifi params_iwconfig_status $THIS_WIFI_DEV
		fi

		cat /tmp/wifi_hardware		
		_wifi params_config
		_wifi tx_and_rx $THIS_WIFI_DEV
	} done
}

_wifi_tx_and_rx ()		# ARG1 = NETWORK_DEV e.g. WIFI_DEV
{
	# WIFI_RX_BYTES=1665694551
	# WIFI_RX_PACKETS=22019893
	# WIFI_RX_ERRORS=0
	# WIFI_RX_FRAMES=109127
	# WIFI_TX_BYTES=2572111365
	# WIFI_TX_PACKETS=22193801
	# WIFI_TX_ERROR=3

	local FILE="/proc/net/dev"

	sed -n "s/^.*$1: *\([0-9]*\) *\([0-9]*\) *\([0-9]*\) *[0-9]* *[0-9]* *\([0-9]*\) *[0-9]* *[0-9]* *\([0-9]*\) *\([0-9]*\) *\([0-9]*\) .*/WIFI_RX_BYTES=\1\nWIFI_RX_PACKETS=\2\nWIFI_RX_ERRORS=\3\nWIFI_RX_FRAMES=\4\nWIFI_TX_BYTES=\5\nWIFI_TX_PACKETS=\6\nWIFI_TX_ERROR=\7/p" "$FILE"
}

_wifi_params_config ()
{
	local FRAG="$(    uci get wireless.radio0.frag )"
	local CHANNEL="$( uci get wireless.radio0.channel )"
	local BSSID="$(   uci get wireless.@wifi-iface[0].bssid )"	# fixme! must be uppercase?

	cat <<EOF
WIFI_CONFIG_FRAG=${FRAG:-2346}
WIFI_CONFIG_CHANNEL=$CHANNEL
WIFI_CONFIG_BSSID=$BSSID
EOF
}

_wifi_params_broadcom_wlstatus ()	# ARG1 = WIFI_DEV ; safe and fast reformatting of 'wl status'-output
{					# for easy eval() BSSID is always uppercase
	# WIFI_DEV=eth1
	# WIFI_UPTIME=0
	# WIFI_ESSID='www.freifunk.net (Zugangspunkt)'
	# WIFI_MODE='Master'
	# WIFI_RSSI='0'						# is signal in [dBm]?
	# WIFI_NOISE='0'
	# WIFI_CHANNEL=7					# convert to MHz ?
	# WIFI_BSSID=00:1D:73:05:0F:59				# own wifi_mac in AP, master_wifi_mac in STA and cell in ADHOC-mode
	# WIFI_RATESET='1(b) 2(b) 5.5(b) 6 9 11(b) 12 18 24 36 48 54'

	_wl $1 status 2>/dev/null |
	 sed -ne "s/'/'\\\''/g;s/^SSID: \"\(.*\)\"/WIFI_DEV=$1\nWIFI_UPTIME=0\nWIFI_ESSID='\1'/p" \
	     -ne "s/^Mode: \([ a-zA-Z]*\).*RSSI: \(.*\) dBm.*noise: \(.*\) dBm.*Channel: \([0-9]*\).*/WIFI_MODE='\1'\nWIFI_RSSI='\2'\nWIFI_NOISE='\3'\nWIFI_CHANNEL=\4/p" \
	     -ne "s/^Supported Rates: \[ \(.*\) \]/WIFI_RATESET='\1'/p" \
	     -ne "/^BSSID: /!d;s/^BSSID: \(..:..:..:..:..:..\).*/WIFI_BSSID=\1/;y/abcdef/ABCDEF/;p"
}

_wifi_params_iwconfig_status ()		# ARG1 = WIFI_DEV
{
	# WIFI_DEV=eth1
	# WIFI_UPTIME=0
	# WIFI_ESSID='www.freifunk.net (Zugangspunkt)'  	# fixme! single quotes are not correct escaped!
	# WIFI_MODE="Managed"
	# WIFI_FREQ=2442					# in MHz ! -> convert to Channel?
	# WIFI_CHANNEL="$( _wifi math_mhz2channel 2442 )"	# this is converted during 'eval'
	# WIFI_BSSID=00:1D:73:05:0F:59  
	# WIFI_SENSITIVITY="0/3"
	# WIFI_RETRY=off
	# WIFI_RTS=256
	# WIFI_FRAG=off
	# WIFI_QUALITY=52
	# WIFI_QUALITY_MAX=94
	# WIFI_SIGNAL='-43'
	# WIFI_NOISE='-95'
	# WIFI_TXPOWER=20	// only seen with atk9k/mac80211

				# fixme! sometimes iwconfig-output is empty

	/usr/sbin/iwconfig $1 2>/dev/null |
	 sed -ne "s/^.*ESSID:\"\(.*\)\"/WIFI_DEV=$1\nWIFI_UPTIME=0\nWIFI_ESSID='\1'/p" \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Access Point: \(.*\)Tx-Power=\([0-9]*\) dBm.*/WIFI_MODE=\1;WIFI_TXPOWER=\3;/p' \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Frequency:\([0-9]\)\.\([0-9]*\).*Access Point: \(..:..:..:..:..:..\)/WIFI_MODE="\1"\nWIFI_FREQ=\2\3\nWIFI_BSSID=\4/p' \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Frequency:\([0-9]\)\.\([0-9]*\).*Cell: \(..:..:..:..:..:..\)/WIFI_MODE="\1"\nWIFI_FREQ=\2\3\nWIFI_CHANNEL=\"\$( _wifi math_mhz2channel \2\3 )\"\nWIFI_BSSID=\4/p' \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Frequency:\([0-9]\)\.\([0-9]*\).*Tx-Power=\([0-9]*\) dBm.*/WIFI_MODE="\1"\nWIFI_FREQ=\2\3\nWIFI_CHANNEL=\"\$( _wifi math_mhz2channel \2\3 )\"\nWIFI_TXPOWER=\4/p' \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Tx-Power=\([0-9]*\) dBm.*/WIFI_MODE=\1;WIFI_TXPOWER=\2;/p' \
	     -ne 's/^.*Bit Rate:.*Tx-Power:.*Sensitivity=\([0-9]*\)\/\([0-9]*\).*/WIFI_SENSITIVITY="\1\/\2"/p' \
	     -ne 's/^.*Retry.\([a-z0-9]*\)[^a-zA-Z0-9]*RTS thr.\([a-z0-9]*\)[^0-9a-zA-Z]*Fragment thr.\([a-z0-9]*\).*/WIFI_RETRY="\1"\nWIFI_RTS="\2"\nWIFI_FRAG="\3"/p' \
	     -ne "s/^.*Link Quality[:=]\([0-9]*\)\/\([0-9]*\).*Signal level[:=]\([-0-9]*\) dBm.*Noise level[:=]\([-0-9]*\) dBm/WIFI_QUALITY=\1\nWIFI_QUALITY_MAX=\2\nWIFI_SIGNAL='\3'\nWIFI_NOISE='\4'/p"
}

_wifi_params_iwconfig_status_debug ()		# only for testing above function
{
	cat >/dev/null <<EOF
ath0      IEEE 802.11b  ESSID:"www.freifunk.net (Zugangspunkt)"  
          Mode:Managed  Frequency:2.442GHz  Access Point: 00:1D:73:05:0F:59  
          Bit Rate:11Mb/s   Tx-Power:0 dBm   Sensitivity=0/3  
          Retry:off   RTS thr:off   Fragment thr:off
          Encryption key:off
          Power Management:off
          Link Quality:52/94  Signal level:-43 dBm  Noise level:-95 dBm
          Rx invalid nwid:8199  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0
EOF

	cat <<EOF
ath0      IEEE 802.11g  ESSID:"hier muss was 'kompliziertes' stehen"   
          Mode:Ad-Hoc  Frequency:2.412 GHz  Cell: 02:0B:6B:DA:95:07   
          Bit Rate:0 kb/s   Tx-Power:19 dBm   Sensitivity=1/1  
          Retry:off   RTS thr:off   Fragment thr=256 B   
          Encryption key:off
          Power Management:off
          Link Quality=0/70  Signal level=-96 dBm  Noise level=-96 dBm
          Rx invalid nwid:389  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0
EOF
}

_wifi_feature_probe ()
{
	local FUNC="wifi_probe_feature"
	local FEATURE="$1"
	
	eval $( _wifi vendor_and_model )	# WIFI_BANDS

	case "$FEATURE" in
		802.11a)
			echo $WIFI_BANDS | grep -q "a" && {
				_log do $FUNC daemon debug "802.11a capable"
				return 0
			}
		;;
		802.11b)
			echo $WIFI_BANDS | grep -q "b" && {
				_log do $FUNC daemon debug "802.11b capable"
				return 0
			}
		;;
		802.11g)
			echo $WIFI_BANDS | grep -q "g" && {
				_log do $FUNC daemon debug "802.11g capable"
				return 0
			}
		;;
	esac
	
	return 1
}

_wifi_phy_set ()		# SENS: switching wifi radio on or off
{
	local WIFI_DEV="$1"	# ARG1: device-name
	local MODE="$2"		# ARG2: string: on|off
	
	if [ "$MODE" = "on" ]; then
		_nvram set wl0_radio 1
		_wifi phy_probe_online $WIFI_DEV || {
			_wifi phy_restart $WIFI_DEV	# only reinit if yet OFF
		}
	else
		_nvram set wl0_radio 0
		_wifi phy_probe_online $WIFI_DEV && {
			_wifi phy_restart $WIFI_DEV	# only reinit if yet ON
		}
	fi
}

_wifi_phy_probe_online ()		# fixme! more abstraction
{
	local WIFI_DEV="$1"
	local VAR="$( uci get wireless.radio0.disabled )"

	if _uci is_oldstyle ; then
		[ "$VAR" = "0" ] && {
			return 1
		}
	else
		[ "$VAR" = "1" ] && {
			return 1
		}
	fi

	return 0
}

_wifi_vendor_and_model ()		# fixme! build lookup-table WIFIDEV -> vendor|model
{
	local WIFI_DEV="$1"
	
	_wifi vendor_and_model_pci
	_wifi vendor_and_model_usb
}

_wifi_vendor_and_model_pci ()			# output can be more than one, how to handle?
{						# ARG1 = WIFI_DEV
	local FILE="/proc/bus/pci/devices"	# evalable_output: WIFI_VENDOR=broadcom;WIFI_MODEL=4318;WIFI_BANDS='b g'

	# Atheros5413 = AR5006X-family = MikroTik RouterBOARD R5H (miniPCI)

	if fgrep -q "0" "$FILE"; then		# dirty but works

		sed	-ne "/168c001b/c\WIFI_VENDOR=atheros ;WIFI_MODEL=5413 ;WIFI_BANDS='a'" \
			-ne "/14e44318/c\WIFI_VENDOR=broadcom;WIFI_MODEL=4318 ;WIFI_BANDS='b g'" \
			-ne "/14e44320/c\WIFI_VENDOR=broadcom;WIFI_MODEL=4306 ;WIFI_BANDS='b g'" \
			-ne "/14e44319/c\WIFI_VENDOR=broadcom;WIFI_MODEL=4319 ;WIFI_BANDS='b g a'" \
			-ne "/168c0012/c\WIFI_VENDOR=atheros ;WIFI_MODEL=5211a;WIFI_BANDS='b g a'" \
			-ne "/168c0013/c\WIFI_VENDOR=atheros ;WIFI_MODEL=5212a;WIFI_BANDS='b g a'" \
			-ne "/168c002a/c\WIFI_VENDOR=atheros ;WIFI_MODEL=AR928X;WIFI_BANDS='a'" \
			"$FILE"
	else
		FILE="/tmp/WIFI_VENDOR_AND_MODEL"

		[ -e "$FILE" ] || {
			if   dmesg | grep -q "Atheros AR9100 MAC/BB Rev:[0-9a-zA-Z]* AR2133"; then
				echo "WIFI_VENDOR=atheros;WIFI_MODEL=2133;WIFI_BANDS='b g'" >"$FILE"
			elif dmesg | grep -q ^"b43-phy0: Broadcom 5352"; then
				echo "WIFI_VENDOR=broadcom;WIFI_MODEL=5352;WIFI_BANDS='b g'" >"$FILE"
			else
				echo "WIFI_VENDOR=unknown;WIFI_MODEL=unknown;WIFI_BANDS='b g'" >"$FILE"
			fi
		}

		cat "$FILE"
	fi
}

_wifi_vendor_and_model_usb ()
{
	# WIFI_VENDOR=ralink;WIFI_MODEL=rt73usb

	sed -ne "/Vendor=148f ProdID=2573/cWIFI_VENDOR=ralink;WIFI_MODEL=rt73usb;WIFI_BANDS='b g'" /proc/bus/usb/devices 2>/dev/null
}

_wifi_driver_version ()
{
	local WIFI_DEV="$1"		# fixme! howto connect DEV -> PHY  (DEV -> DRIVER is no problem)
	local VERSION

	if _wifi driver_is_old_broadcom ; then

		VERSION="$( _wl $WIFI_DEV ver | sed -n 's/^wl:[^0-9]*\(.*\)/\1/p;q' | sed 's/[ ]/-/g' )"	# 3.90-RC37.0
		
		if [ -n "$VERSION" ]; then
			VERSION="wl-adv_${VERSION}_v$( _software package_version wl-adv )"
		else
			VERSION="wl-simple_v$( _software package_version wl )"
		fi
	else
		if _uci is_oldstyle ; then
			VERSION="kmod-madwifi_v$( _software package_version kmod-madwifi )"
		else
			VERSION="kmod-ath9k_v$( _software package_version kmod-ath9k )"
		fi
	fi
	
	echo "$VERSION"
}

_wifi_sensitivity ()
{
	local WIFI_DEV="$1"
	local COMMAND="$2"	# short | mode
	local VALUE
	local OUT

	if _wifi driver_is_old_broadcom ; then

		VALUE="$( _wl $WIFI_DEV interference )"
	
		case "$VALUE" in
			"Auto Wireless LAN Interference mitigation is enabled and not active")
				OUT="0,wifi,auto"
			;;
			"Auto Wireless LAN Interference mitigation is enabled and active")	# just guessed
				OUT="1,wifi,auto"
			;;
			"Wireless LAN Interference mitigation is enabled.")
				OUT="1,wifi,user"
			;;
			"Non-wireless LAN Interference mitigation is enabled.")
				OUT="1,nonwifi,user"
			;;
			"All interference mitigation is disabled.")
				OUT="0,all,user"
			;;
			*)
				OUT="?,wifi,auto"		# e.g. if 'wl-adv' is not installed
			;;
		esac
	else
		eval "$( _wifi params_iwconfig_status $WIFI_DEV | grep ^WIFI_SENSITIVITY= )"	# e.g. '3/3'
		OUT="$WIFI_SENSITIVITY"								# fixme! output more common
	fi

	case $COMMAND in
		short)
			OUT="$( echo $OUT | cut -d',' -f1 )"		# "0,wifi,auto" -> "0"
		;;
		mode)
			OUT="$( echo $OUT | cut -d',' -f2-3 )"		# "0,wifi,auto" -> "wifi,auto"
		;;
	esac
	
	echo "$OUT"
}

_wifi_install_full_broadcomdriver_if_not_installed ()
{
	local FUNC="wifi_install_full_broadcomdriver_if_not_installed"
	local WIFI_DEV="$( _wifi devs_list )"			# fixme!

	_wl $WIFI_DEV ver | grep -q ^"wl:" && return 0
	
	_software packages_install wl-adv && return 0

	_log do $FUNC daemon alert "installing 'wl-adv' was not possible"
		
	return 1
}

_wifi_sensitivity_set ()
{
	local FUNC="wifi_set_sensitivity"
	local WIFI_DEV="$1"
	local METHOD="$2"	# off | auto | wifi | nonwifi

	if _wifi driver_is_old_broadcom ; then
	
		_wifi install_full_broadcomdriver_if_not_installed && {
		
			_log do $FUNC daemon info "setting interference mitigation for '$WIFI_DEV' to '$METHOD'"
		
			case $METHOD in			# fixme! only apply, when method differs from active method
				off)
					_wl $WIFI_DEV interference 0
				;;
				nonwifi)
					_wl $WIFI_DEV interference 1
				;;
				wifi)
					_wl $WIFI_DEV interference 2
				;;
				auto)
					_wl $WIFI_DEV interference 3
				;;
			esac
		}
	else
		# http://madwifi-project.org/ticket/820
		_log do $FUNC daemon info "setting interference mitigation with madwifi does not work"
	fi
}

_wifi_scansupress ()
{
	local WIFI_DEV="$1"
	
	_wl $WIFI_DEV scansuppress
}

_wifi_retry_limit ()
{
	local WIFI_DEV="$1"
	local RETRYTYPE="$2"		# long / short

	_wl $WIFI_DEV srl		# short retrylimit: empty == default == 7	// non RTS/CTS-packets ("big packets")
	_wl $WIFI_DEV lrl		# long  retrylimit: empty == default == 4
}

_wifi_phy_uptime ()	# todo: get/set
{
	a=0
	# cut -d"." -f1 /proc/uptime
	# set
	# get
}

_wifi_phy_restart ()
{
	local FUNC="wifi_phy_restart"
	local WIFI_DEV="$1"
	local REASON="${2:-no_reason_given}"
	local PRIO="${3:-alert}"

	_log do $FUNC daemon $PRIO "working on '$WIFI_DEV' ($REASON)"

	if _wifi driver_is_old_broadcom ; then
	
		wifi					# simply rereads nvram for all broadcom-devices
	else
		if _uci is_oldstyle ; then
			ip link set dev $WIFI_DEV down		# we have seen some strange behaviour with madwifi after that, needs some research!
			ip link set dev $WIFI_DEV up
		else
			wifi "$WIFI_DEV"
		fi
	fi
}

_wifi_phy_txpower_limit ()		# driverlimit/output in [mW]
{
	local WIFI_DEV="$1"
	local FILE="/tmp/WIFI_MAX_DRIVER_TXPOWER_${WIFI_DEV}"
	local OUT

	if _wifi driver_is_old_broadcom ; then
	
		OUT="150"				# fixme! this has to be evaluated!
	else
		if [ -e "$FILE" ]; then
		
			OUT="$( cat "$FILE" )"
		else
			OUT="$( iwlist $WIFI_DEV txpower 2>/dev/null | sed -n 's/^[^a-zA-Z0-9:-]*[0-9]* dBm.*(\([0-9]*\) mW).*/\1/p' | tail -n1 )"
		
			[ -z "$OUT" ] && OUT="$( _wifi phy_txpower $WIFI_DEV )"	# initial value seems to be MAX value

			echo "${OUT:=40}" >$FILE	# conservative fallback-value
		fi
	fi
	
	echo $OUT
}

_wifi_phy_txpower ()		# output in [mW]
{
	local WIFI_DEV="$1"
	local UNIT="$2"		# keyword, can be 'mw', 'dbm', 'qdbm' // fixme! at the moment this IS in [mW]
	local POWER
	
	if _wifi driver_is_old_broadcom ; then

		POWER="$( _wl $WIFI_DEV txpwr | cut -d" " -f3 )"	# this is in [mW]
	else
		if _uci is_oldstyle ; then
			POWER="$( iwlist "$WIFI_DEV" txpower 2>/dev/null | sed -n '/Tx-Power/s/^.*(\([0-9]*\).*/\1/p' )"		# [mW]
		else
			POWER="$( /usr/sbin/iwconfig "$WIFI_DEV" | sed -n 's/^.*Tx-Power=\([0-9]*\).*/\1/p' )"	# [dBm]

			[ -z "$POWER" ] && {
				POWER="$( uci get wireless.radio0.txpower )"
			}
			
			POWER="$( _wifi math_dbm2mw $POWER )"
		fi
	fi
	
	echo "${POWER:-0}"	# no wifi-dev
}

_wifi_phy_txpower_set ()	# e.g.: _wifi phy_txpower_set "$WIFIDEV" 10 mW add overturn
{
	local FUNC="wifi_set_txpower"
	local WIFI_DEV="$1"
	local TXPWR="$2"
	local UNIT="$3"		# keyword, can be 'mw', 'dbm', 'qdbm'	// fixme! at the moment this MUST be [mW]
	local MODE="$4"		# keyword, can be 'add', 'subtract', 'empty = absolute'
	local KEYWORD="$5"	# keyword: 'overturn' (if value is over max, then flip to min)
				#          'limit' (if value is over max or under min, than do nothing)
	
	local VALUE VALUE_DBM VALUE_OLD VALUE_OLD_MW MIN
	local PRIO="debug"
	local MAX="$( _wifi phy_txpower_limit $WIFI_DEV )"	# txpower driverlimit in [mW]
	local FILE_TREND="/tmp/WIFI_TREND_TXPOWER_${WIFI_DEV}"

	case "$( _wifi mode $WIFI_DEV )" in
		adhoc) MIN=10 ;;			# this is a not science-based, but IMHO a senseful value
		    *) MIN=28 ;;			# this is minimal target txpower in [mW]
	esac

	case $MODE in
	    	     add) VALUE="$(( $( _wifi phy_txpower $WIFI_DEV mw ) + $TXPWR ))" ;;
		subtract) VALUE="$(( $( _wifi phy_txpower $WIFI_DEV mw ) - $TXPWR ))" ;;
		       *)
		       	  # mode = "absolute"

		          VALUE="$(     _wifi math_mw2qdbm $TXPWR )"		# value is stored in [qdBm]
			  VALUE_DBM="$( _wifi math_mw2dbm  $TXPWR )"

		       	  VALUE_OLD="$( uci get wireless.radio0.txpower )"
		       	  # VALUE_OLD_MW="$( _wifi math_qdbm2mw $VALUE_OLD )"

		       	  [ "$VALUE" = "$VALUE_OLD" ] && {
		       	  	_log do $FUNC daemon debug "leaving '$WIFI_DEV' as it is"
		       	  	echo "=" >$FILE_TREND
		       	  	return
		       	  }

		       	  [ "$VALUE" -lt "$VALUE_OLD" ] && {
		       	  	PRIO="debug"				# don't spam too much
		       	  	echo "-" >$FILE_TREND
		       	  }

		       	  [ "$VALUE" -gt "$VALUE_OLD" ] && {		# fixme! only spam once, if touching into critical power
		       	  	echo "+" >$FILE_TREND			#	 and getting out of it
		       	  }

		       	  [ "$TXPWR" -gt 55 ] && PRIO="info"		# fixme! was 'alert'

		       	  _log do $FUNC daemon $PRIO "$( cat $FILE_TREND ) for '$WIFI_DEV' to '$TXPWR' mW ('$VALUE' qdBm / '$VALUE_DBM' dBm)"
		       	  _nvram set wl0_txpwr "$VALUE"

			  if _wifi driver_is_old_broadcom ; then

				_wl "$WIFI_DEV" txpwr $TXPWR			# must be in [mW]
			  else
			  	/usr/sbin/iwconfig "$WIFI_DEV" txpower "$VALUE_DBM"  2>/dev/null
			  fi
		       	 
		       	  return 0
		       ;;
	esac

	case "$KEYWORD" in
		overturn)
			[ "$VALUE" -gt "$MAX" ] && VALUE="$MIN"		# fixme! log?
			[ "$VALUE" -lt "$MIN" ] && VALUE="$MAX"
		;;
		limit)
			[ "$VALUE" -gt "$MAX" ] && VALUE="$MAX"
			[ "$VALUE" -lt "$MIN" ] && VALUE="$MIN"
		;;
	esac
	
	_wifi phy_txpower_set "$WIFI_DEV" "$VALUE" mw absolute
}

_wifi_math_mhz2regdomain()
{
	local needed_freq="$1"		# e.g. 2450
	local needed_power="$2"		# e.g. 28	// optional | EIRP [dbm]

	local line country freq1 freq2 channel_width max_ant_db mac_eirp
	local url_regdb="http://git.kernel.org/?p=linux/kernel/git/linville/wireless-regdb.git;a=blob_plain;f=db.txt;hb=HEAD"
	local url_regdb="http://intercity-vpn.de/regdb/db.txt"

	wget -qO - "$url_regdb" |
	 while read line; do {
		case "$line" in							# country AU:
			"country "[A-Z]*)					# 	(2402 - 2482 @ 40), (N/A, 20)
				country="${line#* }"	# all after space	#	(5170 - 5250 @ 40), (3, 23)
				country="${country%:*}"	# all before :		#	(5250 - 5330 @ 40), (3, 23), DFS
			;;							#	(5735 - 5835 @ 40), (3, 30)
			"")							#
				country=					# country XY:
			;;							#	(5150 - 5250 @ 40), (N/A, 200 mW), NO-OUTDOOR
			*)
				[ -n "$country" ] && {
					freq1=; freq2=; channel_width=; max_ant_db=; mac_eirp=
					eval "$( echo $line | sed -n 's/^.*(\([0-9]*\) - \([0-9]*\) @ \([0-9]*\)), (\(.*\), \([0-9]*\)).*/freq1=\1;freq2=\2;channel_width=\3;max_ant_db=\4;max_eirp=\5/p' )"

					[ -n "$freq1" ] && {
						[ $needed_freq -le $freq2 -a $needed_freq -ge $freq1 ] && {
							if [ -n "$needed_power" ]; then
								[ $max_eirp -ge $needed_power ] && {
									echo "$country $line"
								}
							else
								echo "$country $line"
							fi
						}
					}
				}
			;;
		esac
	} done
}

_wifi_math_mhz2channel ()		# http://en.wikipedia.org/wiki/Lost_of_WLAN_channels
{
	local o				# idea: add to each freq regdomain/countrycode
					#       and choose corresponding countrycode, which fits channel 8-)
	case $1 in
		2412) o=1 ;;  # 276	# block of 802.11b/g/n-freqs
		2417) o=2 ;;  # 276
		2422) o=3 ;;  # 276
		2427) o=4 ;;  # 276
		2432) o=5 ;;  # 276
		2437) o=6 ;;  # 276
		2442) o=7 ;;  # 276
		2447) o=8 ;;  # 276
		2452) o=9 ;;  # 276
		2457) o=10 ;; # 276
		2462) o=11 ;; # 276
		2467) o=12 ;; # 276
		2472) o=13 ;; # 276
		2484) o=14 ;;

					# block of 802.11y ommited

		5035) o=7 ;;		# block of 802.11a/h/j/n
            504|5040) o=8 ;;
		5045) o=9 ;;		# fixme! mark 'outdoor'-channels
		5055) o=11 ;;
	    506|5060) o=12 ;;
            508|5080) o=13 ;;

	    517|5170) o=34 ;;
	    518|5180) o=36 ;; # 608 
	    519|5190) o=38 ;;
	     52|5200) o=40 ;; # 608
	    521|5210) o=42 ;; #	608	# TURBO.only	# for TURBO, see http://madwifi-project.org/wiki/UserDocs/802.11a_channels
	    522|5220) o=44 ;; # 608
	    523|5230) o=46 ;;
	    524|5240) o=48 ;; # 608
	    525|5250) o=50 ;; # 608	# TURBO.only	# not listed in wikipedia?
	    526|5260) o=52 ;; # 608
	    528|5280) o=56 ;; # 608
	    529|5290) o=58 ;; # 608	# TURBO.only	# not listed in wikipedia?
	     53|5300) o=60 ;; # 608
	    532|5320) o=64 ;; # 608

	     55|5500) o=100 ;; # 276	# iwconfig-output is '55' and means 5500mhz!
	    552|5520) o=104 ;; # 276
	    553|5530) o=106 ;; # 276	# not listed in wikipedia?
	    554|5540) o=108 ;; # 276
	    556|5560) o=112 ;; # 276
	    557|5570) o=114 ;; # 276	# not listed in wikipedia?
	    558|5580) o=116 ;; # 276
	     56|5600) o=120 ;; # 276
	    561|5610) o=122 ;; # 276	# not listed in wikipedia?
	    562|5620) o=124 ;; # 276
	    564|5640) o=128 ;; # 276
	    565|5650) o=130 ;; # 276	# not listed in wikipedia?
	    566|5660) o=132 ;; # 276
	    568|5680) o=136 ;; # 276
	     57|5700) o=140 ;; # 276
		5745) o=149 ;;
	    576|5760) o=152 ;;	# TURBO.only	# not listed in wikipedia?	# BFWA
		5765) o=153 ;;							# BFWA
		5785) o=157 ;;							# BFWA
	     58|5800) o=160 ;;	# TURBO.only	# not listed in wikipedia?	# BFWA
		5805) o=161 ;;							# BFWA
		5825) o=165 ;;							# BFWA
	    583|5830) o=166 ;;							# BFWA
	        5835) o=167 ;;							# BFWA
	    584|5840) o=168 ;;							# BFWA
		5845) o=169 ;;							# BFWA
	    585|5850) o=170 ;;							# BFWA
		5855) o=171 ;;							# BFWA
	    586|5860) o=172 ;;							# BFWA
		5865) o=173 ;;							# BFWA
	    587|5870) o=174 ;;							# BFWA
		5875) o=175 ;;							# BFWA
		
		4915) o=183 ;;
	    492|4920) o=184 ;;
		4925) o=185 ;;
		4935) o=187 ;;
	    494|4940) o=188 ;;
		4945) o=189 ;;
	    496|4960) o=192 ;;
	    498|4980) o=196 ;;
					# wl also knows: 200, 204, 208, 212, 216
					# oswave.com -> 220/6100mhz, 234...250 (4920...5000mhz), 1...6 (5005....5030)
					
		   *) o=0 ;;		# fixme! till we inserted all freqs
	esac

	echo -n "$o"
}

_wifi_math_mw2dbm ()			# fixme! _sanitizer_convert VALUE unit_is unit_wish
{
	local o				# dBm = 10 * log(mW)	(but -ash can't calc with log)
					# mW  = 10 ^ (dBm/10)
	case $1 in			# (+10 dBm = mW x 10)
	        0) o=0 ;;
	        1) o=1 ;;		# iwlist ath0 txpower
	        2) o=4 ;;		# - Wistron CM9         - Wistron DCM82  - ergo:
	        3) o=5 ;;		#    0 dBm ->  1 mW        0 ->  1	 0 ->  1
	        4) o=6 ;;		#    5 dBm ->  3 mW        4 ->  2	 4 ->  2
	        5) o=7 ;;		#    7 dBm ->  5 mW        6 ->  3	 5 ->  3
	        6) o=8 ;;		#    9 dBm ->  7 mW        8 ->  6	 6 ->  3
	    7|8|9) o=9 ;;		#   11 dBm -> 12 mW       10 -> 10	 7 ->  5
	    10|11) o=10 ;;		#   13 dBm -> 19 mW       12 -> 15	 8 ->  6
	 12|13|14) o=11 ;;		#   15 dBm -> 31 mW       14 -> 25	 9 ->  7
      15|16|17|18) o=12 ;;		#   17 dBm -> 50 mW       16 -> 39	10 -> 10
	    19|20) o=13 ;;		#					11 -> 12
   21|22|23|24|25) o=14 ;;		#					12 -> 15
   					#					13 -> 19
   26|27|28|29|30) o=15 ;;		#					14 -> 25
      31|32|33|34) o=15 ;;		#					15 -> 31
					#					16 -> 39
   35|36|37|38|39) o=16 ;;		#					17 -> 50
   40|41|42|43|44) o=16 ;;		#					18 -> 60
   					#					19 -> 79
   45|46|47|48|49) o=17 ;;		#					20 -> 100
   50|51|52|53|54) o=17 ;;
   55|56|57|58|59) o=17 ;;
   
   60|61|62|63|64) o=18 ;;
   65|66|67|68|69) o=18 ;;
   70|71|72|73|74) o=18 ;;
      75|76|77|78) o=18 ;;
      
      79|80|81|82) o=19 ;;
                *) o=20 ;;
	esac

	echo -n $o	
}

_wifi_math_mw2qdbm ()			# for broadcom on freifunk, convert unit [mW] -> [qdBm] = [1/4 dBm]?
{
	local o
					# nvram 0|78 is both 89 mW
	case $1 in
	 	 2) o=8 ;;
	 	 3) o=16 ;;
	 	 4) o=22 ;;		
		 5) o=27 ;;
		 6) o=30 ;;
		 7) o=33 ;;
		 8) o=36 ;;
		 9) o=38 ;;
		10) o=40 ;;
		11) o=41 ;;
		12) o=43 ;;
		13) o=44 ;;
		14) o=46 ;;
		15) o=47 ;;
		16) o=48 ;;
		17) o=49 ;;
		18) o=50 ;;
		19) o=51 ;;
		20) o=52 ;;
		21) o=53 ;;
	     22|23) o=54 ;;
		24) o=55 ;;
	     25|26) o=56 ;;
		27) o=57 ;;
	     28|29) o=58 ;;
	     30|31) o=59 ;;
		32) o=60 ;;
	     33|34) o=61 ;;
	  35|36|37) o=62 ;;
	     38|39) o=63 ;;
	     40|41) o=64 ;;
          42|43|44) o=65 ;;
             45|46) o=66 ;;
            4[7-9]) o=67 ;;
            5[0-2]) o=68 ;;
            5[3-5]) o=69 ;;
            5[6-9]) o=70 ;;
            6[0-2]) o=71 ;;
            6[3-6]) o=72 ;;
         6[7-9]|70) o=73 ;;
            7[1-4]) o=74 ;;
            7[5-8]) o=75 ;;
         79|8[0-3]) o=76 ;;
            8[4-8]) o=77 ;;
         89|9[0-3]) o=78 ;;
            9[4-9]) o=79 ;;
	   10[0-5]) o=80 ;;
   10[6-9]|110|111) o=81 ;;
           11[2-8]) o=82 ;;
       119|12[0-5]) o=83 ;;
   12[6-9]|13[0-2]) o=84 ;;
       13[3-9]|140) o=85 ;;
           14[1-9]) o=86 ;;
           15[0-7]) o=87 ;;
   158|159|16[0-7]) o=88 ;;
   168|169|17[0-7]) o=89 ;;
   178|179|18[0-7]) o=90 ;;
   188|189|19[0-9]) o=91 ;;
       20[0-9]|210) o=92 ;;
   21[1-9]|22[0-3]) o=93 ;;
   22[4-9]|23[0-6]) o=94 ;;
   23[7-9]|24[0-9]) o=95 ;;
               250) o=95 ;;
           25[1-4]) o=96 ;;
	       255) o=97 ;;
		 *) o=1 ;;
	esac
	
	echo -n "$o"
}

_wifi_antenna_rx_set ()
{
	local FUNC="wifi_set_antenna_rx"
	local WIFI_DEV="$1"
	local ANTENNA="$2"
	local VALUE

	case "$ANTENNA" in
		0) VALUE=0 ;;
		1) VALUE=1 ;;
		*) VALUE=-1 ;;
	esac
	
	_nvram set wl0_antdiv "$VALUE"				# fixme! set it also with '_wl $WIFIDEV rxant ?'

	if _wifi driver_is_old_broadcom ; then  	# fixme! must be device specific

		_wl $WIFI_DEV antdiv $ANTENNA
	else
		case $VALUE in
		       -1)
		       		_log do $FUNC daemon debug "sysctl +dev.wifi0.diversity = 1"
				sysctl -w dev.wifi0.diversity=1
			;;
			*)
				_log do $FUNC daemon debug "sysctl +dev.wifi0.diversity = 0"
				_log do $FUNC daemon debug "sysctl +dev.wifi0.rxantenna = $(( $VALUE + 1 ))"
				sysctl -w dev.wifi0.diversity=0
				sysctl -w dev.wifi0.rxantenna="$(( $VALUE + 1 ))"
			;;
		esac
	fi
}

_wifi_antenna_tx_set ()
{
	local FUNC="wifi_set_antenna_tx"
	local WIFI_DEV="$1"
	local ANTENNA="$2"
	
	case "$ANTENNA" in
		0) VALUE=0 ;;
		1) VALUE=1 ;;
		*) VALUE=-1 ;;
	esac
	
	_nvram set wl0_txant "$VALUE"

	if _wifi driver_is_old_broadcom ; then		# fixme! must be device specific

		_wl $WIFI_DEV txant $ANTENNA
	else
		case $VALUE in
		       -1)
				_log do $FUNC daemon debug "sysctl +dev.wifi0.diversity = 1"
				sysctl -w dev.wifi0.diversity=1
			;;
			*)
				_log do $FUNC daemon debug "sysctl +dev.wifi0.diversity = 0"
				_log do $FUNC daemon debug "sysctl +dev.wifi0.txantenna = $(( $VALUE + 1 ))"
				sysctl -w dev.wifi0.diversity=0
				sysctl -w dev.wifi0.txantenna="$(( $VALUE + 1 ))"
			;;
		esac
	fi
}

_wifi_antenna_rx ()
{
	local WIFI_DEV="$1"
	local RX="$( uci get wireless.radio0.diversity )"

	case $RX in
		0) echo "0" ;;
		1) echo "1" ;;
		*) echo "auto" ;;
	esac
}

_wifi_antenna_tx ()
{
	local WIFI_DEV="$1"
	local TX="$( uci get wireless.radio0.txantenna )"

	if [ "$TX" = "0" ] || [ "$TX" = "1" ]; then
		echo "$TX"
		return
	fi

	echo "auto"
}

_wifi_timing_distance ()
{
	local WIFI_DEV="$1"

	uci get wireless.radio0.distance
}

_wifi_bssid ()				# BSSID = cell in adhoc, ap-wifimac in ap, wifimac of associated ap in client-mode
{
	local WIFI_DEV="$1"		# fixme! check, if this works with broadcom AND madwifi in all conditions
	local SWITCH="$2"		# can be 'config'
	local WIFI_BSSID

	[ "$SWITCH" = "config" ] && {

		case "$( _wifi mode $WIFI_DEV )" in
			adhoc)
				_sanitizer do "$( uci get wireless.@wifi-iface[0].bssid )" lowercase
				return
			;;
			ap)
				_net dev2mac $WIFI_DEV
				return
			;;
			client)
				:	# fixme! return real bssid, because we don't enforce specific AP to connect to (?)
			;;
		esac
	}
	
	if _wifi driver_is_old_broadcom ; then		# fixme! hardware-check must be device specific

		eval "$( _wifi params_broadcom_wlstatus $WIFI_DEV | grep ^WIFI_BSSID= )"
	else
		eval "$( _wifi params_iwconfig_status $WIFI_DEV | grep ^WIFI_BSSID= )"
	fi
	
	_sanitizer do "$WIFI_BSSID" lowercase
}

_wifi_frag ()
{
	local WIFI_DEV="$1"
	
	if _wifi driver_is_old_broadcom ; then		# fixme! hardware-check must be device specific
	
		_wl $WIFI_DEV frag | sed -n 's/^frag is \([0-9]*\).*$/\1/p'
	else
		eval "$( _wifi params_iwconfig_status $WIFI_DEV | grep ^WIFI_FRAG )"
		echo $WIFI_FRAG
	fi
}

_wifi_rts ()
{
	local WIFI_DEV="$1"

	if _wifi driver_is_old_broadcom ; then		# fixme! hardware-check must be device specific
	
		_wl $WIFI_DEV rts | sed -n 's/^rts is \([0-9]*\).*$/\1/p'
	else
		eval "$( _wifi params_iwconfig_status $WIFI_DEV | grep ^WIFI_RTS )"
		echo $WIFI_RTS
	fi
}

_wifi_rate ()
{
	local WIFI_DEV="$1"
	
	if _wifi driver_is_old_broadcom ; then
	
		_wl $WIFI_DEV rate | cut -d' ' -f3		# 1, 2, 5.5, 6, 9, 12 ...
	else
		# /proc/net/madwifi/$WIFI_DEV/associated_sta
		# /proc/net/madwifi/$WIFI_DEV/rate_info		T= max_troughput t=2nd_max_troughput P=max_probability
		# http://www.sfr-fresh.com/linux/misc/madwifi-0.9.4.tar.gz:a/madwifi-0.9.4/ath_rate/minstrel/minstrel.txt
		
		sed -n '/^..P /{s/^...[ ]*\([0-9\.]*\).*/\1/p;q}' /proc/net/madwifi/$WIFI_DEV/rate_info		# first neigh with 'P'
		
		# this is only configured rate
		# Current Bit Rate=54 Mb/s
		# Current Bit Rate:0 kb/s       // 0 means 'auto' ?
		
		# iwlist $WIFI_DEV rate 2>/dev/null | sed -n 's/^.*Bit Rate[:=]\([0-9\.]*\) .*/\1/p'
	fi
}

_wifi_mcastrate ()
{
	local WIFI_DEV="$1"
	local LINE
	
	if _wifi driver_is_old_broadcom ; then		# fixme! hardware-check must be device specific
	
		_wl $WIFI_DEV mrate | cut -d' ' -f3		# 1, 2, 5.5, 6, 9, 12 , auto ...
	else
		if _uci is_oldstyle ; then
			iwpriv $WIFI_DEV get_mcast_rate |
			 sed -n 's/^.*:\([0-9]*\).*/\1/p' |
			  while read LINE; do {
				case $LINE in
					5500) echo 5.5 ;;
					   *) echo $(( $LINE / 1000 )) ;;	
				esac
			} done
		else
			LINE="$( uci get wireless.@wifi-iface[0].mcast_rate )"
			if [ -n "$LINE" ]; then
				case "$LINE" in
					5500000) echo 5.5 ;;
					      *) echo $(( $LINE / 1000 )) ;;
				esac
			else
				echo "auto"
			fi
		fi
	fi
}

_wifi_noise ()			# OUT1: signed Integer, -93 [dBm]
{
	local WIFI_DEV="$1"
	local WIFI_MODE="$( _wifi mode $WIFI_DEV )"
	
	if _wifi driver_is_old_broadcom ; then		# fixme! hardware-check must be device specific
	
		case "$WIFI_MODE" in
			adhoc|client)
				_wl $WIFI_DEV noise | sed 's/[^0-9-]//g'
			;;
			ap)
				echo "0"	# fixme! does not work in broadcom?
			;;
			*)
				echo ""		# ?
			;;
		esac
	else
		[ -e /usr/sbin/iw ] && {
			iw dev $WIFI_DEV survey dump |
			 sed -n '/noise:/{s/^.*noise:.*\(-[0-9]*\).*/\1/p;q}'

			return 0
		}

		eval "$( _wifi params_iwconfig_status $WIFI_DEV | grep ^WIFI_NOISE )"

		case "$WIFI_MODE" in
			adhoc)
				echo $WIFI_NOISE
			;;
			client)
				echo ""		# fixme!
			;;
			ap)
				echo ""		# fixme!
			;;
			*)
				echo ""		# ?
			;;
		esac
	fi
}

_wifi_signal ()			# OUT1: signed Integer, -70 [dBm] or list of $MAC+RSSI of all stations  // fimxe! better concept needed
{
	local WIFI_DEV="$1"
	local WIFI_MODE="$( _wifi mode $WIFI_DEV )"
	local MAC RSSI LOOP LINE

	if _wifi driver_is_old_broadcom ; then		# fixme! hardware-check must be device specific	

		case "$WIFI_MODE" in
			adhoc|client)
				_wl $WIFI_DEV rssi | sed 's/[^0-9-]//g'
			;;
			ap)
				# for MAC in $( _wifi assoclist $WIFI_DEV ); do {
				#	RSSI="$( _wl $WIFI_DEV rssi $MAC | sed -n 's/^rssi is \([0-9-]*\).*/\1/p' )"
				#	echo -n "${LOOP:+:}$( _sanitizer do "$MAC" hex )${RSSI}"
				#	LOOP=1
				# } done
				
				for MAC in $( _wifi assoclist $WIFI_DEV ); do {		# fixme! have seen some dropouts, even with connected clients (looks the same like wrong mac)
					_wl $WIFI_DEV rssi $MAC | cut -d' ' -f3		# can be 0 or even an error!
				} done | sort -n | tail -n1
			;;
			*)
				echo ""		# fixme!
			;;
		esac
	else
		iw dev $WIFI_DEV station dump |
		 while read LINE; do {
			case "$LINE" in
				*"signal avg:"*)
					set $LINE
					echo "$3"
				;;
			esac
		} done | sort -n | tail -n1
	fi
}

_wifi_channel ()
{
	local WIFI_DEV="$1"

	if _wifi driver_is_old_broadcom ; then		# fixme! hardware-check must be device specific
	
		eval "$( _wifi params_broadcom_wlstatus $WIFI_DEV | grep ^WIFI_CHANNEL )"
	else
		eval "$( _wifi params_iwconfig_status $WIFI_DEV | grep ^WIFI_CHANNEL )"
	fi

	echo "$WIFI_CHANNEL"
}

_wifi_protection_gmode ()	# OUT1: integer, 0 | 1
{
	local WIFI_DEV="$1"
	
	if _wifi driver_is_old_broadcom ; then		# fixme! hardware-check must be device specific
	
		_wl $WIFI_DEV gmode_protection | sed -n 's/^gmode_protection is \([0-9]\) .*/\1/p'
	else
		iwpriv $WIFI_DEV get_protmode | sed -n 's/^.*:\([01]\).*/\1/p'
	fi
}

_wifi_assoclist ()		# OUT1: list of associated mac_adresses
{
	local WIFI_DEV="$1"
	local WIFI_MODE="$( _wifi mode $WIFI_DEV )"
	local NOP MAC
	
	if _wifi driver_is_old_broadcom ; then		# fixme! hardware-check must be device specific

		case "$WIFI_MODE" in
			adhoc)
				echo ""		# fixme! howto distinguish from OLSR-neighs?
			;;
			ap)
				_wl $WIFI_DEV assoclist |
				 while read NOP MAC; do {
				 	echo -n "$( _sanitizer do "$MAC" lowercase ) "
				 } done
			;;
			client)
				echo ""		# fixme!
			;;
		esac
	else
		echo ""				# fixme!
	fi
}

_wifi_devs_list ()		# one device per line
{
	sed -n 's/^ *\(.*\): [0-9]*.*/\1/p' /proc/net/wireless
	#  sed -n 's/^ *\([^:]\+\):.*/\1/p' /proc/net/wireless	(sven-ola)
}

_wifi_probe_mode_infrastructure ()		# fixme! respect WIFI_DEV
{
	local WIFI_DEV="$1"
	local SWITCH="$2"	# 'config' or <empty>
	local WIFI_MODE

	if [ "$SWITCH" = "config" ]; then

		case "$( uci get wireless.@wifi-iface[0].mode )" in
			adhoc)
				return 1
			;;
			sta)
				return 1	# fixme! workaround for uci-wrapper
			;;
			*)
				return 0
			;;
		esac
	else
		if _wifi driver_is_old_broadcom ; then		# fixme! hardware-check must be device specific
	
			eval "$( _wifi params_broadcom_wlstatus $WIFI_DEV | grep ^WIFI_MODE= )"
		else
			eval "$( _wifi params_iwconfig_status $WIFI_DEV | grep ^WIFI_MODE= )"
		fi
		
		case $WIFI_MODE in
			Managed|managed|Master|master) return 0 ;;
						    *) return 1 ;;
		esac
	fi
}

_wifi_probe_mode_ap ()				# fixme! respect WIFI_DEV
{
	local WIFI_DEV="$1"
	local SWITCH="$2"	# 'config' or <empty>
	local WIFI_MODE

	if [ "$SWITCH" = "config" ]; then

		if [ "$( uci get wireless.@wifi-iface[0].mode )" = "ap" ]; then
			return 0
		else
			return 1
		fi
	else
		if _wifi driver_is_old_broadcom ; then		# fixme! hardware-check must be device specific

			[ "$( _wl $WIFI_DEV ap | cut -d' ' -f3 )" = "1" ] && WIFI_MODE="Managed"	# 0 = station/client
		else
			eval "$( _wifi params_iwconfig_status $WIFI_DEV | grep ^WIFI_MODE= )"
		fi
		
		case $WIFI_MODE in
			Managed|managed|Master|master) return 0 ;;
						    *) return 1 ;;
		esac
	fi
}

_wifi_phy_mode ()		# fixme! howto describe:
{				# channel-width, compression, frame-aggregation/bursting, plcp-header(=preamble)long/short ...?

	local WIFI_DEV="$1"	# OUT1: string, b | g | bg | gT | a | aT | abg?

	echo "bg"		# fixme!
}

_wifi_mode ()			# OUT1: string, ap | client | adhoc             // rename: wifi_get_mode_conn?
{
	local funcname="wifi_mode"
	local WIFI_DEV="$1"	# fixme! some calls can't provide wifidev - till now we only check nvram, so it does'nt matter
	local SWITCH="$2"	# can be 'config' or <empty>

	fgrep -q "${WIFI_DEV}:" /proc/net/dev || {
		_log do $funcname daemon alert "wifidev $WIFI_DEV not found"
		return 1
	}

	local mode1="$( uci get wireless.@wifi-iface[0].mode )"
	local mode2="$( uci get wireless.@wifi-iface[1].mode )"

	case "$mode1" in
		ap|adhoc)
			case "$mode2" in
				ap|adhoc)
					echo "${mode1}${mode2}"		# fixme! we dont diff between config/real
					return				# fixes e.g. compare_config_and_real_wifi_mode() in watch()
				;;
			esac
		;;
	esac

	if _wifi probe_mode_infrastructure $WIFI_DEV "$SWITCH" ; then
	
		if _wifi probe_mode_ap $WIFI_DEV "$SWITCH" ; then
			echo 'ap'
		else
			echo 'client'	# fixme! output 'sta' or 'station' ?
		fi
	else
		if _wifi probe_mode_ap $WIFI_DEV "$SWITCH" ; then
			echo 'unknown'	
		else
			echo 'adhoc'
		fi
	fi
}

_wifi_scan ()
{
	local FUNC="wifi_scan"
	local WIFI_DEV="$1"
	local KEYWORD="$2"		# intense | normal = <empty>
	local FILE="/tmp/WIFI_SCAN_$$"
	local MYCHANNEL

	[ "$( uci get system.@weblogin[0].enabled )" = "1" ]	&& return		# maybe scanning is unstable
	[ "$( _wifi mode $WIFI_DEV )" != "adhoc" ]		&& return

	if _wifi driver_is_old_broadcom ; then

		if [ "$KEYWORD" = "intense" ]; then

			for MYCHANNEL in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $( _wifi channel $WIFI_DEV ); do {
		
				_nvram set wl0_channel $MYCHANNEL		# fixme! is a hack!
				wifi
				sleep 5

				_wl $WIFI_DEV scan
				sleep 3
				_wl $WIFI_DEV scanresults >$FILE
				_wifi scan_parse_wl $FILE
			} done
		else
			_wl $WIFI_DEV scan
			sleep 3
			_wl $WIFI_DEV scanresults >$FILE
			_wifi scan_parse_wl $FILE
		fi
	else
		touch FILE
		continue	# fixme! needs a parser for iwconfig/madwifi...
	fi
	
	rm $FILE
}

_wifi_scan_parse_wl ()			# OUT: 00184d81a0c2:1:-93:-82:6:WEP:NETGEAR;06180a015e3e:1:-88:-76:8:WEP:Zugangspunkt
{					# which means   BSSID : INFRA/ADHOC=1/0 | RSSI | NOISE | CHANNEL | CRYPT | ESSID + next_entry (separator = ";")
	local FILE="$1"
	local FUNC="wifi_scan_parse_wl"
	local LINE SIGNAL NOISE CHANNEL ESSID BSSID CRYPT INFRA SUMMARY

	while read LINE; do {					# SSID: "FRITZ!Box Fon WLAN 7141"
								# Mode: Managed RSSI: -93 dBm noise: -89 dBm Channel: 10
		case "$( echo $LINE | cut -d: -f1 )" in		# BSSID: 00:04:0E:88:F1:03 Capability: ESS WEP ShortSlot
								# Supported Rates: [ 1(b) 2(b) 5.5(b) 11(b) 6 9 12 18 24 36 48 54 ]
			SSID)
				ESSID="$( echo "$LINE" | sed -n 's/^SSID: "\(.*\)"$/\1/p' )"
				ESSID="$( _sanitizer do "$ESSID" essid )"			# fixme! (escape_all?)
			;;
			Mode)
				# 'Mode: Managed RSSI: -93 dBm noise: -89 dBm Channel: 10'
				# SIGNAL="-93";NOISE="-89";CHANNEL="10"

				eval "$( echo "$LINE" | sed -n 's/^Mode: .*RSSI: \([0-9-]*\).*dBm.*noise: \([0-9-]*\).*dBm.*Channel: \([0-9]*\).*/SIGNAL="\1";NOISE="\2";CHANNEL="\3"/p' )"
			;;
			BSSID)
				# 'BSSID: 00:04:0E:88:F1:03 Capability: ESS WEP ShortSlot'
				
				BSSID="$( echo "$LINE" | sed -n 's/^BSSID: \([0-9a-fA-F:]*\).*/\1/p' )"
				[ "$( echo $BSSID | cut -d':' -f1 )" = "02" ] && INFRA=0
				BSSID="$( _sanitizer do "$BSSID" hex lowercase )"
	
				echo "$LINE" | grep -q "WEP" && CRYPT="w"	# idea: w = wep / W=WPA ?
			;;
			"")
				[ -z "$BSSID" ] && continue
				SUMMARY="${BSSID}:${INFRA:=1}:${CRYPT:=0}:${CHANNEL}:${SIGNAL}:${NOISE}:${ESSID}"

				_log do $FUNC daemon info "PHY_${WIFI_DEV}_chan_$( _wifi channel $WIFI_DEV ): '${SUMMARY}'"
				
				_wifi scan_summary insert $BSSID "${SUMMARY}"

				BSSID=;INFRA=;SIGNAL=;NOISE=;CHANNEL=;CRYPT=;ESSID=;SUMMARY=
			;;
		esac
			
	} done <$FILE
}

_wifi_scan_summary ()
{
	local FUNC="scan_summary"
	local KEYWORD="$1"		# remove | insert | show | get = <empty>
	local OBJ1="$2"			# when 'insert' -> bssid to insert
	local OBJ2="$3"			# when 'insert' -> data to insert

	local FILE_BSSID LOOP OUT
	local DIR="/tmp/WIFI_SCAN_TODAY"
	
	[ -d $DIR ] || mkdir $DIR

	case "$KEYWORD" in
		remove)
			rm $DIR/* 2>/dev/null
		;;
		insert)
			echo "$OBJ2" >>$DIR/$OBJ1
		;;
		*)
			for FILE_BSSID in $( ls -1 $DIR ); do {
				OUT="$( sort -n $DIR/$FILE_BSSID | head -n1 )"		# only show strongest received beacon

				[ "$( echo $OUT | cut -d':' -f2 )" = "1" ] && {		# infra=1? / sometimes we get an wrong BSSID even for an AP like: 00:1a:2a:73:14:05 (real) -> 9e:dd:8b:b3:b1:38 (random!)
					_net mac2vendor $FILE_BSSID 2>/dev/null >/dev/null || {
						OUT=
						_log do $FUNC daemon debug "ommitting entry for ESSID '$FILE_BSSID' - mac2vendor() does not work"
					}
				}

				[ -n "$OUT" ] && {
					if [ "$KEYWORD" = "show" ]; then
						echo $OUT
					else
						echo -n "${LOOP:+;}${OUT}"
						LOOP=1
					fi
				}
			} done
		;;
	esac
}

_wifi_rrdhelper ()		# fixme! is a hack for rrd-tool
{
	local WIFI_DEV="$1"
	local SENSOR
	
	for SENSOR in rate noise rssi phy_txpower nlq; do {
		[ "$SENSOR" = "rssi" ] && SENSOR=signal
		_wifi $SENSOR $WIFI_DEV >/tmp/WIFI_VALUE_DEV_${WIFI_DEV}_${SENSOR}
	} done
}

_wifi_nlq ()			# fixme! is a hack for rrd-tool
{
	local FILE="/tmp/WIFI_OPTIMIZE_NEIGH"
	local OUT
	
	if [ -e "$FILE" ]; then
		OUT="$( neigh get_nlq "$( cat $FILE 2>/dev/null )" )"
		echo $(( ${OUT:-0} / 10 ))
	else
		echo "0"
	fi
}

_wifi_math_dbm2mw ()			# mW  = 10 ^ (dBm/10)
{
	local o

	case $1 in
		0) o=1 ;;
		4) o=2 ;;
		5) o=3 ;;
		6) o=3 ;;
		7) o=5 ;;
		8) o=6 ;;
		9) o=7 ;;
		10) o=10 ;;
		11) o=12 ;;
		12) o=15 ;;
		13) o=19 ;;
		14) o=25 ;;
		15) o=31 ;;
		16) o=39 ;;
		17) o=50 ;;
		18) o=60 ;;
		19) o=79 ;;
		20) o=100 ;;
		21) o=126 ;;
		22) o=158 ;;
		23) o=200 ;;
		24) o=251 ;;
		25) o=316 ;;
		26) o=398 ;;
		27) o=501 ;;
		28) o=631 ;;
		29) o=794 ;;
		30) o=1000 ;;
	esac

	echo -n $o
}

_wifi_typeof()				# returns e.g. "mac80211"
{
	local check_ifname="$1"		# e.g. wlan0

	. /etc/functions.sh

	find_device_type()
	{
		local section="$1"

		local ifname
		config_get ifname "$section" ifname

		[ "$ifname" = "$check_ifname" ] && {
			local device
			config_get device "$section" device

			local type
			config_get type "$device" type

			[ -n "$type" ] && {
				echo $type
				return 1
			}
		}
	}

	config_load wireless
	config_foreach find_device_type wifi-iface
}

_wifi_check_each_client()
{
	local mac ip list_macs exitcode list_already_known_macs local up1 up2 up_diff
	local funcname="wifi_check_each_client"
	local max_arping="10"
	local statsdir="/tmp/$funcname"

	mkdir -p "$statsdir"
	_net include

	list_macs="$( iw dev $WIFIDEV station dump | grep ^Station | cut -d' ' -f2 )"

	for mac in $list_macs; do {		# fixme! only check client with low inactivity time
		[ "$exitcode" = "0" ] || {
			ip="$( _net mac2ip $mac )" && {
				if arping -q -f -c $max_arping -I $WIFIDEV $ip ; then
					_log do $funcname daemon debug "[OK] arping - mac: $mac ip: $ip"
					exitcode="0"
				else
					_log do $funcname daemon info "[ERR] arping - mac: $mac ip: $ip (no success for $max_arping probes)"
					exitcode="1"
				fi
			}
		}

		[ -e "$statsdir/$mac" ] || {
			_log do $funcname daemon info "[OK] detected new station $mac"
			_system uptime >"$statsdir/$mac"
		}
	} done

	station_is_valid()
	{
		iw dev $WIFIDEV station get "${1:-unset}" 2>/dev/null >/dev/null
	}

	list_already_known_macs="$( ls -1 "$statsdir" 2>/dev/null )"

	for mac in $list_already_known_macs; do {		# fixme! writeout traffic_counter
		station_is_valid "$mac" || {
			up2="$( _system uptime )"
			read up1 <"$statsdir/$mac"
			rm "$statsdir/$mac"
			up_diff="$(( $up2 - $up1 ))"

			_log do $funcname daemon alert "[OK] station $mac left network $WIFIDEV, ($( _stopwatch seconds2humanreadable $up_diff ))"
		}
	} done

	return ${exitcode:-0}
}
